## 1. 类型转换重载
### 1.1. 类型转换分类
1. 显式类型转换：在程序中直接提出要做转换，通过使用类型转换运算符形成表达式；
2. 隐式类型转换：编译器发现某个类型不适合这个语境，从而自动发生的类型转换
   隐式类型转换发生的场合则比较多。我们已经知道的，在以下时机会发生从 `A` 类型到 `B` 类型的转换：
   - 用 `A` 类型初始化 `B` 类型的变量。这其中又包括：
      - 声明并定义 `B` 类型变量，其中初始化值是 `A` 类型的；
      - 函数形参期望是 `B` 类型的，而实参是 `A` 类型的；
      - 函数返回值类型期望是 `B`，而 `return` 语句中的表达式是 `A` 类型的；
   - 某个运算符期待 `B` 类型操作数，但实际给出的操作数却是 `A` 类型的；
   - 在 `if` `while` 和 `for` 的条件表达式中，可以将 `A` 类型转换到 `bool`
### 1.2. explicit关键字
考虑从 `String` 到 `bool` 再到 `int`的转换，这会导致：
```cpp
int main() {
    String a("42");
    int val{a}; // 猜猜 val 是多少？
}
```
显然 `val` 不能是 `42`。`val` 的值是从 `bool` 类型转换过来的，而 `String` 值 `"42"` 转换到 `bool` 是 `true`，`true` 转换到 `int` 是 `1`，所以答案是 `1`

为了解决这一意想不到的情况, C++引入了 `explicit` 关键字。它表明：这个转换只能用于显式转换，不能用于隐式转换。
```cpp codemo(show)
struct B {};
struct C {};
struct A {
    A() { }
    explicit A(const C&) { }              // 只允许显式的从 C 到 A 的转换
    explicit operator B() { return B(); } // 只允许显式的从 A 到 B 的转换
};
int main() {
    A a; B b; C c;
//  a = c;    // 不许隐式转换
    a = A(c); // 但可以显式转换
//  b = a;    // 不许隐式转换
    b = B(a); // 但可以显式转换
}
```

对于我们而言，我们不想要隐式的从 `String` 到 `bool` 的转换，所以把它标记为 `explicit` 的。但这是不是就引发了这样的问题：我们没有办法直接在 `if` 里面用 `String` 了？
```cpp
int main() {
    String a;
    if (a) { } // a 不能隐式转换到 bool 了？
}
```
实际上这个问题并不存在。因为 C++ 提供了一个例外判断，如果在形如：
- `if` `for` `while` 条件；
- `&&` `||` `!` 操作数，`?:` 第一操作数；

等这样的条件下，则也考虑显式类型转换。这种例外判断称为“按语境转换到 `bool`”

## 2. 只读成员函数重载
### 2.1. 只读成员函数
假如有一个类 `A`，它有一个成员数据 `data` 和一个成员函数 `change`：
```cpp codemo(show)
struct A {
    int data;
    void change() {
        data++;
    }
};
int main() {
    const A a;
//  a.change();  // 编译错误
}
```
那么，在 `main` 函数里面声明并定义只读的 `A` 类型对象 `a`。如果 `a` 的 `change` 能被调用的话，`a` 的 `data` 成员就会发生更改，这就不符合“只读”的含义了。所以默认情形下不能调用只读对象的成员函数. 

如果想要一个只读对象的成员函数可以被调用，需要给这个函数整体加上 `const` 限定。它的语法是：
```sdsc
返回值类型 类名"::"成员函数名"("[参数列表]") const" 函数体
```
也就是说把 `const` 关键字加在参数列表和函数体之间。这种被整体 `const` 限定的成员函数称为只读成员函数。比如：
```cpp
struct A {
    int data;
    void change() const {
//      data++; // 编译错误
    }
};
```
很显然，只读成员函数内部不能对成员数据做更改，也不能调用非只读的成员函数。只读成员函数中的 `this`指针 类型是 `const T*` 的. 

### 2.2. 只读成员函数重载
考虑 `operator[]` 函数. 
```cpp
char& String::operator[](unsigned pos) {
    return str[pos];
}
```
这个函数该不该被整体 `const` 限定呢？如果不设置为只读的，那么我就没法对只读对象调用 `operator[]` 了。但如果设置为只读的，那么 `a[0] = '@'` 还是编译不过
```cpp
char& String::operator[](unsigned pos) const {
    return str[pos]; // 编译错误：不能将只读类型绑定到非只读引用上去
}
```
最终的解决方法是利用函数重载，声明两个 `operator[]` 成员函数，分别对应只读和非只读的版本：
```cpp
// 非只读版本
char& String::operator[](unsigned pos) {
    return str[pos];
}
// 只读版本
const char& String::operator[](unsigned pos) const {
    return str[pos];
}
```
然后，在调用 `operator[]` 时，编译器会优先选择整体带 `const` 限定的重载；如果不能，则选择非只读的
```cpp
int main() {
    const String a("Hello");
    String b("Hello");
    a[0]; // 调用只读版本
    b[0]; // 调用非只读版本
}
```

## 3. 静态成员
### 3.1. 成员列表中的静态成员变量大多只能是声明而非定义

```cpp
struct A {
    static int a; // 这是声明，不是定义！
};
int main() {
    A::a = 42;    // 错误：A::a 未定义
}
```
上面这段代码，看上去没什么问题，但实际上会报一个未定义错误。这是因为，当写下不带初始化器的静态成员声明时，编译器并不会把它当成一个完整的定义，而是当做一个声明（就类似 `void f();` 这样）。这时如果使用了这个变量就会导致未定义错误。那么解决的办法就是写一个定义了：
```cpp codemo(show)
struct A {
    static int a; // 是声明，不是定义
};
int A::a{0};      // 我们要在类外定义它（不带 static）
int main() {
    A::a = 42;    // OK 了
}
```

像这样，将静态成员的定义单独以类外定义的形式给出总是 OK 的。但如果想要写成下面这种类内定义的形式就有些问题了：

```cpp
struct A {
    static int a{0}; // 错误：非内联非只读的静态成员不能定义
};
```
这是对于非内联的变量，如果在类定义内给出变量定义，则会潜在地导致其在不同翻译单元内重复定义，从而导致链接错误. 于是 C++ 直接在语法层面避免了这个错误. 
### 3.2. 内联的静态成员变量可以在类内定义
这里的内联是链接时允许重复定义的意思。
```cpp codemo(show)
struct A {
    static inline int a{0}; // 可以类内定义了
};
int main() {
    A::a = 42; // OK
}
```
### 3.3. 只读的静态成员变量一般允许在类内定义(有附加条件) 
对于 const 非内联静态成员数据，若要ODR-使用它，则必须存在一个类外定义
| 静态成员变量只读性 | 内联性        | 可以类内定义？ | 可以类外定义？ |
| ------------------ | ------------- | -------------- | -------------- |
| 非只读             | 非内联        | 否             | 是             |
| 非只读                | `inline` 修饰 | 是             | 是             |
| `const` 限定       | 非内联        | 是(限制如上)      | 是             |
| `const` 限定           | `inline` 修饰 | 是             | 是             |
| `constexpr` 限定   | 内联          | 是             | 否             |   
